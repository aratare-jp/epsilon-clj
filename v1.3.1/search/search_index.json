{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! epsilon-clj is a codebase generator based on Eclipse Epsilon , written in Clojure and thus sprinkled with sweetness. It is created to help you develop applications faster, and more importantly, have fun while doing it. It does so by: Being fast so you can do more things Being hot-reloadable so you can code at your own speed Being reliable so you don't have to fight the tool Being consistent so you can get the same result no matter where you use it If you are new to Clojure, no worries. You don't need to know the language to use this library. If you're new to codebase generator, also no worries. I'll cover more in-depth concepts in later sections. This entire documentation website has been designed to give you a more hands-on experience, and thus to familiarise you with new concepts without overwhelming you \ud83d\ude09\ud83d\udc4d Feeling excited? Let's get started!","title":"Home"},{"location":"#welcome","text":"epsilon-clj is a codebase generator based on Eclipse Epsilon , written in Clojure and thus sprinkled with sweetness. It is created to help you develop applications faster, and more importantly, have fun while doing it. It does so by: Being fast so you can do more things Being hot-reloadable so you can code at your own speed Being reliable so you don't have to fight the tool Being consistent so you can get the same result no matter where you use it If you are new to Clojure, no worries. You don't need to know the language to use this library. If you're new to codebase generator, also no worries. I'll cover more in-depth concepts in later sections. This entire documentation website has been designed to give you a more hands-on experience, and thus to familiarise you with new concepts without overwhelming you \ud83d\ude09\ud83d\udc4d Feeling excited? Let's get started!","title":"Welcome!"},{"location":"about/","text":"About What is it? epsilon-clj is a codebase generator based on Eclipse Epsilon and written in Clojure. Codebase generation is similar to text or code generation, but instead works on a much larger picture, i.e. the codebase itself. In a nutshell, instead of generating a single file, you'll generate an entire codebase. Sounds cool, right? Info You may be wondering: a code generator can also generate an entire codebase. And you'd be right. Here I'm using the term codebase generator to put emphasis on the fact that this library is mainly for generating codebase rather than individual pieces, which you can also do by the way \ud83d\ude09 How does codebase generation work? Codebase generation involves two main parts: templates , and, if applicable, models . Generally speaking, codebase generators read in templates , which have various \"slots\" where they require additional information. They also require models , which provides these additional information to fill those \"slots\". For example, let's say that we have a template like this: Hello, {name}! This template contains a single \"slot\" that requires an additional piece of information: name . So if we combine this template with a model like this: { \"name\" : \"Bob\" } This model provides that additional piece of information we are looking for. Thus, when you run codebase generation on these two pieces, you will have Hello, Bob! Almost all generators work like this. But, here therein lies the problem with conventional generation. Where it falls short Conventional generation works in top-down fashion: Information flows from models to templates. As you can see from the example above, once you've reached the final stage (i.e. Hello, Bob! ), and this is what we want. However, there will be times when you need to be able to place custom code. But, this introduces a challenge: Where do you place this custom code? An obvious answer is the templates , but that means it will affect all other generated files, and that may not be what you want. Another answer is the generated files , but this means it will be overwritten the next time you regenerate. Some may say that we can put them inside custom templates, which are imported whenever we need them. This approach will still affect other generated files, unless you have conditional import, which is something Eclipse Epsilon itself does not support. So, then, how do we solve this problem? The answer is: protected regions . The return of the templates Protected regions are special \"slots\" inside your templates that effectively tell the codebase generator \"I want this region right here preserved\". This means that anything you write inside these \"slots\" will not be overwritten no matter how many times you regenerate. Imagine you use these templates to generate a small project, may be a small HTML static website, for your friend. One day, she wants to change the logo. Since she doesn't have your templates, anything she changes will be gone the next time either of you regenerates. You want to keep the templates, but you also want to allow her to change the logo. The solution: putting the logo inside a protected region. This means that any changes she makes to the logo will be guaranteed to stay there no matter how many times either of you regenerates the project. In a nutshell, it ensures freedom to customise while still giving you the benefits of a codebase generator. Why this library Eclipse Epsilon is good and modern, but it also contains lots of problems when you start using it a bit more extensively: APIs feel outdated and neglected. No javadoc and documentation for lots of things. Everything is single-threaded, so scaling up requires investing a lot of time to mitigate this. Since there are lots of shared states and singletons, even moving to multi-threading takes a lot of time. Lots of functionality requires Eclipse's exclusive packages, which are not the easiest to find if you want to build your own wrapper. Confusing and sometimes outright infuriating errors that are inconsistent and hard to debug. The above list are just some of the problems I've personally encountered when using Epsilon. Some of which have been resolved since then, but a lot still remains. This is where epsilon-clj enters the scene. epsilon-clj was created to bring a much more streamlined experience where you can use what you need, and it will take care of the rest. Generating a file is as simple as calling a function with the template, the models and where you want to put the file, and leave the back-scene configurations to epsilon-clj to take care. It also aims to either solve or work around the aforementioned problems and bring great features like template hot-reload so you can work faster and happier(!) without interruption. So, head over to the next page to try epsilon-clj out!. Happy coding!","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#what-is-it","text":"epsilon-clj is a codebase generator based on Eclipse Epsilon and written in Clojure. Codebase generation is similar to text or code generation, but instead works on a much larger picture, i.e. the codebase itself. In a nutshell, instead of generating a single file, you'll generate an entire codebase. Sounds cool, right? Info You may be wondering: a code generator can also generate an entire codebase. And you'd be right. Here I'm using the term codebase generator to put emphasis on the fact that this library is mainly for generating codebase rather than individual pieces, which you can also do by the way \ud83d\ude09","title":"What is it?"},{"location":"about/#how-does-codebase-generation-work","text":"Codebase generation involves two main parts: templates , and, if applicable, models . Generally speaking, codebase generators read in templates , which have various \"slots\" where they require additional information. They also require models , which provides these additional information to fill those \"slots\". For example, let's say that we have a template like this: Hello, {name}! This template contains a single \"slot\" that requires an additional piece of information: name . So if we combine this template with a model like this: { \"name\" : \"Bob\" } This model provides that additional piece of information we are looking for. Thus, when you run codebase generation on these two pieces, you will have Hello, Bob! Almost all generators work like this. But, here therein lies the problem with conventional generation.","title":"How does codebase generation work?"},{"location":"about/#where-it-falls-short","text":"Conventional generation works in top-down fashion: Information flows from models to templates. As you can see from the example above, once you've reached the final stage (i.e. Hello, Bob! ), and this is what we want. However, there will be times when you need to be able to place custom code. But, this introduces a challenge: Where do you place this custom code? An obvious answer is the templates , but that means it will affect all other generated files, and that may not be what you want. Another answer is the generated files , but this means it will be overwritten the next time you regenerate. Some may say that we can put them inside custom templates, which are imported whenever we need them. This approach will still affect other generated files, unless you have conditional import, which is something Eclipse Epsilon itself does not support. So, then, how do we solve this problem? The answer is: protected regions .","title":"Where it falls short"},{"location":"about/#the-return-of-the-templates","text":"Protected regions are special \"slots\" inside your templates that effectively tell the codebase generator \"I want this region right here preserved\". This means that anything you write inside these \"slots\" will not be overwritten no matter how many times you regenerate. Imagine you use these templates to generate a small project, may be a small HTML static website, for your friend. One day, she wants to change the logo. Since she doesn't have your templates, anything she changes will be gone the next time either of you regenerates. You want to keep the templates, but you also want to allow her to change the logo. The solution: putting the logo inside a protected region. This means that any changes she makes to the logo will be guaranteed to stay there no matter how many times either of you regenerates the project. In a nutshell, it ensures freedom to customise while still giving you the benefits of a codebase generator.","title":"The return of the templates"},{"location":"about/#why-this-library","text":"Eclipse Epsilon is good and modern, but it also contains lots of problems when you start using it a bit more extensively: APIs feel outdated and neglected. No javadoc and documentation for lots of things. Everything is single-threaded, so scaling up requires investing a lot of time to mitigate this. Since there are lots of shared states and singletons, even moving to multi-threading takes a lot of time. Lots of functionality requires Eclipse's exclusive packages, which are not the easiest to find if you want to build your own wrapper. Confusing and sometimes outright infuriating errors that are inconsistent and hard to debug. The above list are just some of the problems I've personally encountered when using Epsilon. Some of which have been resolved since then, but a lot still remains. This is where epsilon-clj enters the scene. epsilon-clj was created to bring a much more streamlined experience where you can use what you need, and it will take care of the rest. Generating a file is as simple as calling a function with the template, the models and where you want to put the file, and leave the back-scene configurations to epsilon-clj to take care. It also aims to either solve or work around the aforementioned problems and bring great features like template hot-reload so you can work faster and happier(!) without interruption. So, head over to the next page to try epsilon-clj out!. Happy coding!","title":"Why this library"},{"location":"installation/","text":"Installation Prerequisites Java 11 Setting up CLI Installing epsilon-clj is as easy as downloading a JAR file and executing it: wget https://github.com/aratare-jp/epsilon-clj/releases/download/v1.3.1/epsilon-v1.3.1-standalone.jar You can also manually download the latest executable here . Programmatic For those who want to integrate epsilon-clj into your application, you can put epsilon-clj into your dependencies.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequisites","text":"Java 11","title":"Prerequisites"},{"location":"installation/#setting-up","text":"","title":"Setting up"},{"location":"installation/#cli","text":"Installing epsilon-clj is as easy as downloading a JAR file and executing it: wget https://github.com/aratare-jp/epsilon-clj/releases/download/v1.3.1/epsilon-v1.3.1-standalone.jar You can also manually download the latest executable here .","title":"CLI"},{"location":"installation/#programmatic","text":"For those who want to integrate epsilon-clj into your application, you can put epsilon-clj into your dependencies.","title":"Programmatic"},{"location":"quick-start/","text":"Quick Start Hi there! Glad you decided to give this a try. Here we will use epsilon-clj to build a mini website for a library to demonstrate what codebase generation can give you. Some new concepts will be introduced along the way with examples to follow, so you can see how things come together. Ready? Let's get started! 1. Let's set things up! First, you need to install epsilon-clj . Open a new terminal window and enter the following commands: 1 2 3 4 5 # Our new project directory. mkdir awesome_epsilon # Move to the newly created directory. cd awesome_epsilon For this tutorial, we will do things in a terminal, so follow the CLI section in the Installation guide to set epsilon-clj up. For now, our project directory will look like this: awesome_epsilon \u2514\u2500\u2500 epsilon-v1.3.1-standalone.jar 2. Let's make a model! The first thing you need is a model. A model is essentially a representation of a domain, concept or \"thing\". For example: Toy car models are little representations of real-life cars. A flowchart is a representation of a process. A scientific model represents a certain phenomenon in real life. A model captures the essence of a domain or problem that you are working on. Since we are building a library website, our model will represent our library. A model in epsilon-clj is just a plain XML file. So create a file called library.xml in our newly created directory and insert following content into it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" public= \"true\" > <id> EMFBook </id> <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" public= \"true\" > <id> EMPBook </id> <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" public= \"false\" > <id> Eclipse3FAQs </id> <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> You can see we have a root library element which contains multiple book elements, each has its own attributes like title and page , as well as author . Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u2514\u2500\u2500 library.xml A model alone is not enough. The reason is simple: It just stores data in a certain shape or form. However, to display these data, e.g. which data to show, which data to ignore, simple strings manipulation, etc. you will need some templates . 3. Let's create some templates! A template is like a blueprint. You build or create things based on what is described in the blueprint, just like building a house or assembling a car. Each template will generate a file based on whatever content you have in them (but not every kind of content as we will see later). However, templates alone are not enough: We need specific details. Having only a house blueprint is not really useful without the details and measurements. Templates receive these details and measurements from models. To illustrate this, let's create our very first template. First, we need a place to store these templates. Create a directory called templates and a template file called book.html.egl . Now, insert the following content into book.html.egl : 1 2 3 4 5 6 7 <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [% for (author in book.c_author) { %] <li>[%=author.text%] [% } %] </ul> Let's go through some interesting things we just did: At line 1, we create an h1 HTML tag based on a book's index and title . From line 4 to 6, we create li tags based on a book's author. Info Some hawkeyes out there may be wondering where index came from. After all, there was no index in the model. It actually came from somewhere else, as we'll see shortly. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u2514\u2500\u2500 templates \u2514\u2500\u2500 book.html.egl I won't go too deep into EGL syntax, but a more interesting question is: How does this template understand which book to use? The answer is: Template coordinator , as we will see in the very next section shortly. 4. Let's create a template coordinator! A template requires a coordinator, sort of like a controller telling what the template should do. It is also used to expose certain data, handle validations, tell the template where to output, etc. In the same directory as our template, let's create a file called home.html.egx with the following content: 1 2 3 4 5 6 7 8 9 10 rule Book2PageHTML transform book : t_book { guard : book.b_public parameters { var params : new Map; params.put(\"index\", t_book.all.indexOf(book) + 1); return params; } template : \"book.html.egl\" target : book.e_id.text + \".html\" } Wow, that's a lot. Let's dissect what is going on here: At line 1, you are declaring that you want to output the template below for every book. At line 2, you are declaring that you only want to output for books that are public. At line 3 to 7, you are exposing certain data to the template. Remember that index at line 1 in the template? This is where it comes from. The passed-in data always comes as a map. At line 8, you are declaring that this controller will use the book.html.egl template, which you just created earlier. This works as a relative path. At line 9, you are declaring you want to output an HTML file whose name comes from the ID of the book. This is relative to the output directory you're about to give epsilon-clj . Tip You can have multiple rules in a coordinator file. However, it can be tricky to manage since it's hard to know which template generates which files when you're working backward. Having, say, book.html.egl and EMPBook.html can make things easier when you want to know where EMPBook.html came from. Info Speaking of nice features, epsilon-clj requires its name to be the same as the template it's controlling, e.g. book.html.egl and book.html.egx , for hot-reloading. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u2514\u2500\u2500 templates \u251c\u2500\u2500 book.html.egl \u2514\u2500\u2500 book.html.egx 5. Let's start generating some files! Eh, not so fast, tiger! There is one last thing you need: where your generated files should go! So let's make a new directory called output in our root directory. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output Now we can generate some files. epsilon-clj requires three things: template , model and output directories. Run the following command in your terminal: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate Let's break this down: -d templates indicates all the templates are in the templates directory. -m library.xml indicates you want to use library.xml model. -o output indicates you want to output files at output . generate tells you want to generate files using the provided arguments. It should take a few seconds for epsilon-clj to parse everything and start doing its work. Once it's done, your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output \u251c\u2500\u2500 EMPBook.html \u2514\u2500\u2500 EMFBook.html Notice the two new generated files inside output : EMPBook.html and EMFBook.html . Let's have a look at their content: EMFBook.html < h1 > Book 1: EMF Eclipse Modeling Framework </ h1 > < h2 > Authors </ h2 > < ul > < li > Dave Steinberg </ li > < li > Frank Budinsky </ li > < li > Marcelo Paternostro </ li > < li > Ed Merks </ li > </ ul > EMPBook.html < h1 > Book 2: Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit </ h1 > < h2 > Authors </ h2 > < ul > < li > Richard Gronback </ li > </ ul > Congratulations! You have just created the library website. You can open these files in a browser to check out their beauty. 6. Let's see some magic! If you've worked with other generators before, this may seem to be similar to, well, all of them except the syntax. So what's so special about epsilon-clj and Eclipse Epsilon ? Let's first have some observation: Everything we've done until now is one-way: models -> templates -> generated files. This means that if you want to include other things in the generated files, they will be rewritten the next time you regenerate! The only way forward is to include them in the templates. However, sometimes there are things you want to specifically have in the generated files, but makes no sense to have them in the templates. Let's imagine our library example website is so good we start selling them to people. Let's say one client wants to add a new piece of information at the bottom of each book. How do you approach this? You can't include it in the generated files for the stated reason, but it also makes no sense to make it in the template because other clients may not want it. This is where protected region comes in. Protected regions are special places inside the generated files where you can safely insert your custom stuff without the fear of them being rewritten. In this case it is a perfect place for our custom code. Let's make some changes to our book.html.egl template: 1 2 3 4 5 6 7 8 <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [% for (author in book.c_author) { %] <li>[%=author.text%] [% } %] </ul> [%= protected(out, \"<!--\", \"Enter your custom code here\", false, \"-->\") %] Notice the last line: this is where we declare a protected region. Run this again: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate After which EMPBook.html and EMFBook.html will have something like this at the end of the file: <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> <!-- protected region Enter your custom code here end --> Anything between those two lines will be reserved throughout future regenerations. So let's insert some cool code into EMPBook.html : <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> < h1 > Epsilon is awesome! </ h1 > <!-- protected region Enter your custom code here end --> Rerun the previous command and check the content of EMPBook.html again, and you'll see: <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> <!-- protected region Enter your custom code here end --> Hang on! That's not right! Where's the custom code? It turns out that protected regions are by default disabled: notice the word off at the end. Turn it on by simply replace off with on , and then add the custom code again and rerun the command. You will now see: <!-- Omit for brevity --> <!-- protected region Enter your custom code here on begin --> < h1 > Epsilon is awesome! </ h1 > <!-- protected region Enter your custom code here end --> Magic! Question So why are protected regions disabled by default if we're just going to use them anyway? It turns out that protected regions can also have default content, i.e. things you want to put there by default. For example, let's say we have: [%= startProtected(out, \"<!--\", \"Enter your custom code here\", false, \"-->\") %] <h1>Hello world!</h1> [%= endProtected(out) %] it will generate something like this: <!-- protected region Enter your custom code here off begin --> < h1 > Hello world! </ h1 > <!-- protected region Enter your custom code here end --> It is suitable for places where you want to have default content but also allow users to change the content later on. Info You can actually turn protected regions on automatically by replacing false with true when using it. For example: [%= startProtected(out, \"<!--\", \"Enter your custom code here\", true, \"-->\") %] [%= endProtected(out) %] will produce: <!-- protected region Enter your custom code here on begin --> <!-- protected region Enter your custom code here end --> 7. Let's do some validation! (Optional) As your model gets bigger, you may want to do some validation on your model to make sure your templates will not cause issues because it can't find an element in your model. So in this section, we'll make a quick validation file to handle such case. Let's create a file called book.evl inside your template directory. Your project should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.evl \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output \u251c\u2500\u2500 EMPBook.html \u2514\u2500\u2500 EMFBook.html Insert the following code into book.evl : 1 2 3 4 5 6 context t_book { constraint ValidAuthors { check : self.c_author.size() > 0 message: \"Book \" + self.e_id.text + \" needs to have more than one author\" } } Let's break it down: At line 1, we want to run this validation against all book elements in the model. At line 2, we name this constraint/rule \"ValidAuthors\". At line 3, we want to validate that every book has at least 1 author. At line 4, if the previous validation failed, display a custom message to the console. Much like template coordinators, you can have as many constraints inside a context, and as many contexts inside a validation file as you want. When you use generate command, it will first validate the model by using all the validations inside your template directory before generating anything. If you only want to only validate, consider using the validate command: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output validate 8. One more thing By now, I'm sure you have gotten quite tired of having to run this command 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate every time you want to regenerate. Fortunately, epsilon-clj got you covered! By simply enabling hot-reload with the -w flag, epsilon-clj will automatically regenerate whenever it sees a file change inside your templates. For example, this command: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output -w generate will regenerate whenever there's a file change inside templates . Info Not just EGL files, EVL files will also trigger a validation run. For more options, check out this page . 9. Wrapping things up That's it! Let's recap: You've learnt what models and templates are and how they can work together to create a codebase. You've learnt how just creating files won't be enough for customisation, and how protected regions can solve this. You've learnt how epsilon-clj can provide some nice features like hot-reload so you can work much faster. In the end, Eclipse Epsilon is just another generator. By having a merge engine to allow us to include special places, we can truly take advantage of codebase generation without the fear of customisation. As a parting gift, you can learn more about Epsilon's syntax here . Happy coding!","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Hi there! Glad you decided to give this a try. Here we will use epsilon-clj to build a mini website for a library to demonstrate what codebase generation can give you. Some new concepts will be introduced along the way with examples to follow, so you can see how things come together. Ready? Let's get started!","title":"Quick Start"},{"location":"quick-start/#1-lets-set-things-up","text":"First, you need to install epsilon-clj . Open a new terminal window and enter the following commands: 1 2 3 4 5 # Our new project directory. mkdir awesome_epsilon # Move to the newly created directory. cd awesome_epsilon For this tutorial, we will do things in a terminal, so follow the CLI section in the Installation guide to set epsilon-clj up. For now, our project directory will look like this: awesome_epsilon \u2514\u2500\u2500 epsilon-v1.3.1-standalone.jar","title":"1. Let's set things up!"},{"location":"quick-start/#2-lets-make-a-model","text":"The first thing you need is a model. A model is essentially a representation of a domain, concept or \"thing\". For example: Toy car models are little representations of real-life cars. A flowchart is a representation of a process. A scientific model represents a certain phenomenon in real life. A model captures the essence of a domain or problem that you are working on. Since we are building a library website, our model will represent our library. A model in epsilon-clj is just a plain XML file. So create a file called library.xml in our newly created directory and insert following content into it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" public= \"true\" > <id> EMFBook </id> <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" public= \"true\" > <id> EMPBook </id> <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" public= \"false\" > <id> Eclipse3FAQs </id> <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> You can see we have a root library element which contains multiple book elements, each has its own attributes like title and page , as well as author . Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u2514\u2500\u2500 library.xml A model alone is not enough. The reason is simple: It just stores data in a certain shape or form. However, to display these data, e.g. which data to show, which data to ignore, simple strings manipulation, etc. you will need some templates .","title":"2. Let's make a model!"},{"location":"quick-start/#3-lets-create-some-templates","text":"A template is like a blueprint. You build or create things based on what is described in the blueprint, just like building a house or assembling a car. Each template will generate a file based on whatever content you have in them (but not every kind of content as we will see later). However, templates alone are not enough: We need specific details. Having only a house blueprint is not really useful without the details and measurements. Templates receive these details and measurements from models. To illustrate this, let's create our very first template. First, we need a place to store these templates. Create a directory called templates and a template file called book.html.egl . Now, insert the following content into book.html.egl : 1 2 3 4 5 6 7 <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [% for (author in book.c_author) { %] <li>[%=author.text%] [% } %] </ul> Let's go through some interesting things we just did: At line 1, we create an h1 HTML tag based on a book's index and title . From line 4 to 6, we create li tags based on a book's author. Info Some hawkeyes out there may be wondering where index came from. After all, there was no index in the model. It actually came from somewhere else, as we'll see shortly. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u2514\u2500\u2500 templates \u2514\u2500\u2500 book.html.egl I won't go too deep into EGL syntax, but a more interesting question is: How does this template understand which book to use? The answer is: Template coordinator , as we will see in the very next section shortly.","title":"3. Let's create some templates!"},{"location":"quick-start/#4-lets-create-a-template-coordinator","text":"A template requires a coordinator, sort of like a controller telling what the template should do. It is also used to expose certain data, handle validations, tell the template where to output, etc. In the same directory as our template, let's create a file called home.html.egx with the following content: 1 2 3 4 5 6 7 8 9 10 rule Book2PageHTML transform book : t_book { guard : book.b_public parameters { var params : new Map; params.put(\"index\", t_book.all.indexOf(book) + 1); return params; } template : \"book.html.egl\" target : book.e_id.text + \".html\" } Wow, that's a lot. Let's dissect what is going on here: At line 1, you are declaring that you want to output the template below for every book. At line 2, you are declaring that you only want to output for books that are public. At line 3 to 7, you are exposing certain data to the template. Remember that index at line 1 in the template? This is where it comes from. The passed-in data always comes as a map. At line 8, you are declaring that this controller will use the book.html.egl template, which you just created earlier. This works as a relative path. At line 9, you are declaring you want to output an HTML file whose name comes from the ID of the book. This is relative to the output directory you're about to give epsilon-clj . Tip You can have multiple rules in a coordinator file. However, it can be tricky to manage since it's hard to know which template generates which files when you're working backward. Having, say, book.html.egl and EMPBook.html can make things easier when you want to know where EMPBook.html came from. Info Speaking of nice features, epsilon-clj requires its name to be the same as the template it's controlling, e.g. book.html.egl and book.html.egx , for hot-reloading. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u2514\u2500\u2500 templates \u251c\u2500\u2500 book.html.egl \u2514\u2500\u2500 book.html.egx","title":"4. Let's create a template coordinator!"},{"location":"quick-start/#5-lets-start-generating-some-files","text":"Eh, not so fast, tiger! There is one last thing you need: where your generated files should go! So let's make a new directory called output in our root directory. Your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output Now we can generate some files. epsilon-clj requires three things: template , model and output directories. Run the following command in your terminal: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate Let's break this down: -d templates indicates all the templates are in the templates directory. -m library.xml indicates you want to use library.xml model. -o output indicates you want to output files at output . generate tells you want to generate files using the provided arguments. It should take a few seconds for epsilon-clj to parse everything and start doing its work. Once it's done, your directory should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output \u251c\u2500\u2500 EMPBook.html \u2514\u2500\u2500 EMFBook.html Notice the two new generated files inside output : EMPBook.html and EMFBook.html . Let's have a look at their content: EMFBook.html < h1 > Book 1: EMF Eclipse Modeling Framework </ h1 > < h2 > Authors </ h2 > < ul > < li > Dave Steinberg </ li > < li > Frank Budinsky </ li > < li > Marcelo Paternostro </ li > < li > Ed Merks </ li > </ ul > EMPBook.html < h1 > Book 2: Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit </ h1 > < h2 > Authors </ h2 > < ul > < li > Richard Gronback </ li > </ ul > Congratulations! You have just created the library website. You can open these files in a browser to check out their beauty.","title":"5. Let's start generating some files!"},{"location":"quick-start/#6-lets-see-some-magic","text":"If you've worked with other generators before, this may seem to be similar to, well, all of them except the syntax. So what's so special about epsilon-clj and Eclipse Epsilon ? Let's first have some observation: Everything we've done until now is one-way: models -> templates -> generated files. This means that if you want to include other things in the generated files, they will be rewritten the next time you regenerate! The only way forward is to include them in the templates. However, sometimes there are things you want to specifically have in the generated files, but makes no sense to have them in the templates. Let's imagine our library example website is so good we start selling them to people. Let's say one client wants to add a new piece of information at the bottom of each book. How do you approach this? You can't include it in the generated files for the stated reason, but it also makes no sense to make it in the template because other clients may not want it. This is where protected region comes in. Protected regions are special places inside the generated files where you can safely insert your custom stuff without the fear of them being rewritten. In this case it is a perfect place for our custom code. Let's make some changes to our book.html.egl template: 1 2 3 4 5 6 7 8 <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [% for (author in book.c_author) { %] <li>[%=author.text%] [% } %] </ul> [%= protected(out, \"<!--\", \"Enter your custom code here\", false, \"-->\") %] Notice the last line: this is where we declare a protected region. Run this again: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate After which EMPBook.html and EMFBook.html will have something like this at the end of the file: <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> <!-- protected region Enter your custom code here end --> Anything between those two lines will be reserved throughout future regenerations. So let's insert some cool code into EMPBook.html : <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> < h1 > Epsilon is awesome! </ h1 > <!-- protected region Enter your custom code here end --> Rerun the previous command and check the content of EMPBook.html again, and you'll see: <!-- Omit for brevity --> <!-- protected region Enter your custom code here off begin --> <!-- protected region Enter your custom code here end --> Hang on! That's not right! Where's the custom code? It turns out that protected regions are by default disabled: notice the word off at the end. Turn it on by simply replace off with on , and then add the custom code again and rerun the command. You will now see: <!-- Omit for brevity --> <!-- protected region Enter your custom code here on begin --> < h1 > Epsilon is awesome! </ h1 > <!-- protected region Enter your custom code here end --> Magic! Question So why are protected regions disabled by default if we're just going to use them anyway? It turns out that protected regions can also have default content, i.e. things you want to put there by default. For example, let's say we have: [%= startProtected(out, \"<!--\", \"Enter your custom code here\", false, \"-->\") %] <h1>Hello world!</h1> [%= endProtected(out) %] it will generate something like this: <!-- protected region Enter your custom code here off begin --> < h1 > Hello world! </ h1 > <!-- protected region Enter your custom code here end --> It is suitable for places where you want to have default content but also allow users to change the content later on. Info You can actually turn protected regions on automatically by replacing false with true when using it. For example: [%= startProtected(out, \"<!--\", \"Enter your custom code here\", true, \"-->\") %] [%= endProtected(out) %] will produce: <!-- protected region Enter your custom code here on begin --> <!-- protected region Enter your custom code here end -->","title":"6. Let's see some magic!"},{"location":"quick-start/#7-lets-do-some-validation-optional","text":"As your model gets bigger, you may want to do some validation on your model to make sure your templates will not cause issues because it can't find an element in your model. So in this section, we'll make a quick validation file to handle such case. Let's create a file called book.evl inside your template directory. Your project should now look like this: awesome_epsilon \u251c\u2500\u2500 epsilon-v1.3.1-standalone.jar \u251c\u2500\u2500 library.xml \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 book.evl \u2502 \u251c\u2500\u2500 book.html.egl \u2502 \u251c\u2500\u2500 book.html.egx \u2514\u2500\u2500 output \u251c\u2500\u2500 EMPBook.html \u2514\u2500\u2500 EMFBook.html Insert the following code into book.evl : 1 2 3 4 5 6 context t_book { constraint ValidAuthors { check : self.c_author.size() > 0 message: \"Book \" + self.e_id.text + \" needs to have more than one author\" } } Let's break it down: At line 1, we want to run this validation against all book elements in the model. At line 2, we name this constraint/rule \"ValidAuthors\". At line 3, we want to validate that every book has at least 1 author. At line 4, if the previous validation failed, display a custom message to the console. Much like template coordinators, you can have as many constraints inside a context, and as many contexts inside a validation file as you want. When you use generate command, it will first validate the model by using all the validations inside your template directory before generating anything. If you only want to only validate, consider using the validate command: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output validate","title":"7. Let's do some validation! (Optional)"},{"location":"quick-start/#8-one-more-thing","text":"By now, I'm sure you have gotten quite tired of having to run this command 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output generate every time you want to regenerate. Fortunately, epsilon-clj got you covered! By simply enabling hot-reload with the -w flag, epsilon-clj will automatically regenerate whenever it sees a file change inside your templates. For example, this command: 1 java -jar epsilon-v1.3.1-standalone.jar -d templates -m library.xml -o output -w generate will regenerate whenever there's a file change inside templates . Info Not just EGL files, EVL files will also trigger a validation run. For more options, check out this page .","title":"8. One more thing"},{"location":"quick-start/#9-wrapping-things-up","text":"That's it! Let's recap: You've learnt what models and templates are and how they can work together to create a codebase. You've learnt how just creating files won't be enough for customisation, and how protected regions can solve this. You've learnt how epsilon-clj can provide some nice features like hot-reload so you can work much faster. In the end, Eclipse Epsilon is just another generator. By having a merge engine to allow us to include special places, we can truly take advantage of codebase generation without the fear of customisation. As a parting gift, you can learn more about Epsilon's syntax here . Happy coding!","title":"9. Wrapping things up"},{"location":"resources/","text":"Resources Here you can find more resources on various topics we've covered previously. Model-Driven Software Development Eclipse Epsilon Clojure","title":"Resources"},{"location":"resources/#resources","text":"Here you can find more resources on various topics we've covered previously.","title":"Resources"},{"location":"resources/#model-driven-software-development","text":"","title":"Model-Driven Software Development"},{"location":"resources/#eclipse-epsilon","text":"","title":"Eclipse Epsilon"},{"location":"resources/#clojure","text":"","title":"Clojure"},{"location":"troubleshooting/","text":"Troubleshooting This document serves as a place where you can find some of the most annoying and obscure bugs in Epsilon. Some of them are results of oversight and others are by design. Hopefully this page will give you the help you need to debug your templates. No file generated Symptoms Output directory does not contain any files, or all generated files remain unchanged. Reason This problem mostly occurs when you have used an unknown variable or types, and hence mainly a semantic error. However, note that this is caused by something like this: [%= foo %] or [% foo; %] which is quite different from the blank generated files bug . Remedy Check what epsilon-clj is printing out on the CLI, or returns from function calls. Check what variables you are referencing incorrectly and use the correct ones. Partially missing content Symptoms Your generated files are missing some content but not all. Reason This is mainly caused by a mismatch tag within your template. For example: 1 2 [% [%= \"blah\" %] The annoyance of this bug is the fact this is not classified as a grammatical error by Epsilon. Thus Epsilon will happily parse everything and move on, even though the syntax is wrong. Unfortunately, this also means epsilon-clj cannot catch such problem. Remedy Check where the content is missing in your generated file and cross-reference with the template to see which tag is missing its counterpart. Blank generated files Symptoms Your generated files are completely blank. Reason Unlike this bug , this is only caused by statement blocks that miss semi-colons. For example: [% foo %] However, Epsilon does not recognise that this is a grammatical error and thus should report immediately. Instead it will continue parsing and generating everything. Unfortunately, there is no such way for epsilon-clj to intercept or recognise this either. Remedy Unfortunately, it is quite hard to track down because, well, you have nothing in the generated files to cross-reference. Usually this is quite easy for other languages to pick up when you have a linter, but the Epsilon ecosystem is quite limited in terms of tooling. My recommendation for this bug is to do a manual scan through your templates and check where you're missing the semi-colons. To make matter worse, if your templates are referencing a buggy template, you will need to check them as well. This is, by far, the worst bug of Epsilon due to its obnoxious symptoms and cause, compounded by difficulty to debug and remedy.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"This document serves as a place where you can find some of the most annoying and obscure bugs in Epsilon. Some of them are results of oversight and others are by design. Hopefully this page will give you the help you need to debug your templates.","title":"Troubleshooting"},{"location":"troubleshooting/#no-file-generated","text":"","title":"No file generated"},{"location":"troubleshooting/#symptoms","text":"Output directory does not contain any files, or all generated files remain unchanged.","title":"Symptoms"},{"location":"troubleshooting/#reason","text":"This problem mostly occurs when you have used an unknown variable or types, and hence mainly a semantic error. However, note that this is caused by something like this: [%= foo %] or [% foo; %] which is quite different from the blank generated files bug .","title":"Reason"},{"location":"troubleshooting/#remedy","text":"Check what epsilon-clj is printing out on the CLI, or returns from function calls. Check what variables you are referencing incorrectly and use the correct ones.","title":"Remedy"},{"location":"troubleshooting/#partially-missing-content","text":"","title":"Partially missing content"},{"location":"troubleshooting/#symptoms_1","text":"Your generated files are missing some content but not all.","title":"Symptoms"},{"location":"troubleshooting/#reason_1","text":"This is mainly caused by a mismatch tag within your template. For example: 1 2 [% [%= \"blah\" %] The annoyance of this bug is the fact this is not classified as a grammatical error by Epsilon. Thus Epsilon will happily parse everything and move on, even though the syntax is wrong. Unfortunately, this also means epsilon-clj cannot catch such problem.","title":"Reason"},{"location":"troubleshooting/#remedy_1","text":"Check where the content is missing in your generated file and cross-reference with the template to see which tag is missing its counterpart.","title":"Remedy"},{"location":"troubleshooting/#blank-generated-files","text":"","title":"Blank generated files"},{"location":"troubleshooting/#symptoms_2","text":"Your generated files are completely blank.","title":"Symptoms"},{"location":"troubleshooting/#reason_2","text":"Unlike this bug , this is only caused by statement blocks that miss semi-colons. For example: [% foo %] However, Epsilon does not recognise that this is a grammatical error and thus should report immediately. Instead it will continue parsing and generating everything. Unfortunately, there is no such way for epsilon-clj to intercept or recognise this either.","title":"Reason"},{"location":"troubleshooting/#remedy_2","text":"Unfortunately, it is quite hard to track down because, well, you have nothing in the generated files to cross-reference. Usually this is quite easy for other languages to pick up when you have a linter, but the Epsilon ecosystem is quite limited in terms of tooling. My recommendation for this bug is to do a manual scan through your templates and check where you're missing the semi-colons. To make matter worse, if your templates are referencing a buggy template, you will need to check them as well. This is, by far, the worst bug of Epsilon due to its obnoxious symptoms and cause, compounded by difficulty to debug and remedy.","title":"Remedy"},{"location":"usage/CLI/","text":"Command-line Interface epsilon-clj put emphasis on being able to integrate generation workflow into your own. Having a library that does not have a CLI introduces some complexities when you want to take advantage of your CI/CD, and thus epsilon-clj should avoid being that library. This page serves as a reference guide on different commands and options you can use. Info For most up-to-date commands and options, use -h or --help option. It is also assumed that you have installed epsilon-clj . If not, check out Installation page . The general structure of a typical epsilon-clj command is like this: 1 java -jar epsilon-v1.3.1-standalone.jar [ options ] [ command ] Options Short form Long form Description -h --help Display help message. -d --dir Template directory. Can be relative or absolute. -m --model Path to XML model to use. Can be relative or absolute. Can be used multiple times. -o --output Where to output the templates. Can be relative or absolute. -v Verbosity level; may be specified up to 2 times. Levels: INFO -> DEBUG -> TRACE -w --watch Watch the given template directory. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration. Commands generate Generate all files. Requires template directory model paths output directory Important This option will run validation against the models before generation. validate Validate all models. Requires template directory model paths watch Standalone watch mode. Requires template directory model paths output directory Important This command is identical like the watch option. Note that this option will not validate or generate anything beforehand. Examples # Display help message. $ java -jar epsilon-v1.3.1-standalone.jar -h # Execute generation with a model, a template directory and an output directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" generate # Execute watch mode with a model, a template directory and an output directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" -w generate # Execute validation with a model and a template directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" validate # Execute standalone watch mode. $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" watch","title":"CLI"},{"location":"usage/CLI/#command-line-interface","text":"epsilon-clj put emphasis on being able to integrate generation workflow into your own. Having a library that does not have a CLI introduces some complexities when you want to take advantage of your CI/CD, and thus epsilon-clj should avoid being that library. This page serves as a reference guide on different commands and options you can use. Info For most up-to-date commands and options, use -h or --help option. It is also assumed that you have installed epsilon-clj . If not, check out Installation page . The general structure of a typical epsilon-clj command is like this: 1 java -jar epsilon-v1.3.1-standalone.jar [ options ] [ command ]","title":"Command-line Interface"},{"location":"usage/CLI/#options","text":"Short form Long form Description -h --help Display help message. -d --dir Template directory. Can be relative or absolute. -m --model Path to XML model to use. Can be relative or absolute. Can be used multiple times. -o --output Where to output the templates. Can be relative or absolute. -v Verbosity level; may be specified up to 2 times. Levels: INFO -> DEBUG -> TRACE -w --watch Watch the given template directory. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration.","title":"Options"},{"location":"usage/CLI/#commands","text":"","title":"Commands"},{"location":"usage/CLI/#generate","text":"Generate all files. Requires template directory model paths output directory Important This option will run validation against the models before generation.","title":"generate"},{"location":"usage/CLI/#validate","text":"Validate all models. Requires template directory model paths","title":"validate"},{"location":"usage/CLI/#watch","text":"Standalone watch mode. Requires template directory model paths output directory Important This command is identical like the watch option. Note that this option will not validate or generate anything beforehand.","title":"watch"},{"location":"usage/CLI/#examples","text":"# Display help message. $ java -jar epsilon-v1.3.1-standalone.jar -h # Execute generation with a model, a template directory and an output directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" generate # Execute watch mode with a model, a template directory and an output directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" -w generate # Execute validation with a model and a template directory $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" validate # Execute standalone watch mode. $ java -jar epsilon-v1.3.1-standalone.jar -m \"model.xml\" -d \"templates\" -o \"gen\" watch","title":"Examples"},{"location":"usage/programmatic/","text":"Programmatic epsilon-clj also allows you to integrate programmatically with your codebase. Overall, it exposes several useful functions which you can call in your code. generate-all Given a template directory, model paths and output directory, generate all templates found in the template directory. ( require ' [ epsilon.generator :as gen ]) ( gen/generate-all \"templates\" [ \"model.xml\" ] \"output\" false ) The above example will take all the templates inside templates , combined with model.xml , and generate files inside output . The last boolean false indicates we don't want watch mode. Info This function will validate all models before generating. If failed, generation will halt. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration if generate-all is in watch mode. validate-all Similar to generate-all but only validates models. For example: ( require ' [ epsilon.generator :as gen ]) ( gen/validate-all \"templates\" [ \"model.xml\" ] false ) It also takes a boolean to indicate if you want watch mode. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration if validate-all is in watch mode. generate Take a single template and run generation with it. ( require ' [ epsilon.generator :as gen ]) ( gen/generate \"templates/foo.egx\" [ \"model.xml\" ] \"output\" ) validate Take a single EVL file and run validation with it. ( require ' [ epsilon.generator :as gen ]) ( gen/validate \"templates/foo.evl\" [ \"model.xml\" ]) watch Watch over a directory for file changes. It takes a list of predicates which will be run against file changes to determine if it should be kept or not. For example: ( require ' [ epsilon.generator :as gen ]) ( gen/watch \"templates\" [ \"model.xml\" ] \"output\" [ egl? egx? ]) will trigger a regeneration every time a template or template coordinator is changed. Important watch , as well as generate-all and validate-all in watch mode will not block the current thread. Instead, when called in watch mode they will return a map that has 2 keys: :future and :handler . :handler refers to the function that when called when stop the current watcher. :future refers to the CompletableFuture returned by the watch service. Use this to join the watcher thread. ( require ' [ epsilon.generator :as gen ]) ( let [{ :keys [ handler future ]} ( gen/watch \"templates\" [ \"model.xml\" ] \"output\" )] ;; Call this function will stop the watcher thread. ( handler ) ;; Wait for the watcher thread to finish and then join it. ( .get future )) The above code block will also work for generate-all and validate-all in watch mode.","title":"Programmatic"},{"location":"usage/programmatic/#programmatic","text":"epsilon-clj also allows you to integrate programmatically with your codebase. Overall, it exposes several useful functions which you can call in your code.","title":"Programmatic"},{"location":"usage/programmatic/#generate-all","text":"Given a template directory, model paths and output directory, generate all templates found in the template directory. ( require ' [ epsilon.generator :as gen ]) ( gen/generate-all \"templates\" [ \"model.xml\" ] \"output\" false ) The above example will take all the templates inside templates , combined with model.xml , and generate files inside output . The last boolean false indicates we don't want watch mode. Info This function will validate all models before generating. If failed, generation will halt. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration if generate-all is in watch mode.","title":"generate-all"},{"location":"usage/programmatic/#validate-all","text":"Similar to generate-all but only validates models. For example: ( require ' [ epsilon.generator :as gen ]) ( gen/validate-all \"templates\" [ \"model.xml\" ] false ) It also takes a boolean to indicate if you want watch mode. Important Due to a certain bug , on Windows, any modification to the models will not trigger regeneration if validate-all is in watch mode.","title":"validate-all"},{"location":"usage/programmatic/#generate","text":"Take a single template and run generation with it. ( require ' [ epsilon.generator :as gen ]) ( gen/generate \"templates/foo.egx\" [ \"model.xml\" ] \"output\" )","title":"generate"},{"location":"usage/programmatic/#validate","text":"Take a single EVL file and run validation with it. ( require ' [ epsilon.generator :as gen ]) ( gen/validate \"templates/foo.evl\" [ \"model.xml\" ])","title":"validate"},{"location":"usage/programmatic/#watch","text":"Watch over a directory for file changes. It takes a list of predicates which will be run against file changes to determine if it should be kept or not. For example: ( require ' [ epsilon.generator :as gen ]) ( gen/watch \"templates\" [ \"model.xml\" ] \"output\" [ egl? egx? ]) will trigger a regeneration every time a template or template coordinator is changed. Important watch , as well as generate-all and validate-all in watch mode will not block the current thread. Instead, when called in watch mode they will return a map that has 2 keys: :future and :handler . :handler refers to the function that when called when stop the current watcher. :future refers to the CompletableFuture returned by the watch service. Use this to join the watcher thread. ( require ' [ epsilon.generator :as gen ]) ( let [{ :keys [ handler future ]} ( gen/watch \"templates\" [ \"model.xml\" ] \"output\" )] ;; Call this function will stop the watcher thread. ( handler ) ;; Wait for the watcher thread to finish and then join it. ( .get future )) The above code block will also work for generate-all and validate-all in watch mode.","title":"watch"}]}